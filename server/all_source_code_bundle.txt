
==================== FILE: config.py ====================

# --- Image Analysis Settings (edit directly) ---
import os

# --- Path Configuration ---
# Dynamically construct the absolute path to the service account key,
# assuming it is in the same directory as this config file.
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
FIREBASE_SERVICE_ACCOUNT_KEY_PATH = os.path.join(BASE_DIR, "serviceAccountKey.json")
# --- End of Path Configuration ---

# CWA API Authorization Key (edit directly here)
CWA_API_KEY = "CWA-F3565C7E-B3CB-42AF-B86E-E882A5DAF79F"

# NCDR API Details (edit directly if used)
NCDR_API_BASE_URL = "YOUR_NCDR_API_URL_HERE"
NCDR_API_KEY = "YOUR_NCDR_API_KEY_HERE"

# Discord Webhook URL (edit directly if used)
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1424684753357111369/Cgo20EKHKCZd3eO9wJUDQmLtsTlupgTgTiA1fJyFR667cAqWAo8HeHCRyjpYKcyYLXVt"

# --- Image Analysis Settings (edit directly) ---
# URLs for rain probability and AQI images to analyze
RAIN_PROBABILITY_IMAGE_URL = ""
AQI_IMAGE_URL = ""

# Separate images for 12h and 6h PoP if provided (fallback to RAIN_PROBABILITY_IMAGE_URL)
POP12_IMAGE_URL = RAIN_PROBABILITY_IMAGE_URL
POP6_IMAGE_URL = RAIN_PROBABILITY_IMAGE_URL

# If the URLs are dynamic, provide strftime patterns here; resolver will try the latest.
# Examples (you should replace with real patterns when known):
#   "https://example.cwa.gov.tw/pop12_%Y%m%d%H.png"
#   "https://example.cwa.gov.tw/pop6_%Y%m%d%H.png"
POP12_URL_PATTERNS = ["https://npd.cwa.gov.tw/NPD/image/BC_QPF_12_%Y%m%d%H.png"]  # type: ignore[var-annotated]
POP6_URL_PATTERNS = ["https://npd.cwa.gov.tw/NPD/image/BC_QPF_06_%Y%m%d%H.png"]   # type: ignore[var-annotated]
AQI_URL_PATTERNS = ["https://airtw.epa.gov.tw/EnvStatus/map_static_img/AQI_Day.png"]    # type: ignore[var-annotated]

# Crop/sample boxes (left,upper,right,lower). Set to None or a 4-tuple.
RAIN_PROBABILITY_CROP_BOX = None
AQI_SAMPLE_BOX = None

# Specific crop boxes for PoP12/PoP6 if they reside in different regions of the same image
POP12_CROP_BOX = None
POP6_CROP_BOX = None

# Optional path to Tesseract executable (Windows)
TESSERACT_CMD = ""

# HTTP/TLS settings
# If True (default), requests will verify HTTPS certificates.
# Set to False ONLY if you encounter local CA issues and understand the risk.
REQUESTS_VERIFY_SSL = True

# If True, when a SSL error occurs for CWA API, allow one retry with verify=False.
# Keep False unless you are blocked by local CA issues.
ALLOW_INSECURE_FALLBACK = True

# --- QPF Color Map and Sampling Coordinates ---
# Map representative RGB colors (as tuples) to rainfall intensity (mm/hr).
# Calibrate these values to match the legend of the CWA QPF images you use.
QPF_COLOR_MAP = {
    (0, 0, 255): 0.5,
    (0, 255, 255): 1.0,
    (0, 255, 0): 5.0,
    (255, 255, 0): 10.0,
    (255, 165, 0): 20.0,
    (255, 0, 0): 40.0,
    (128, 0, 128): 80.0,
}

# Per-county pixel coordinates for sampling on the QPF map.
# Coordinates are (x, y) in pixels.
IMAGE_SAMPLE_COORDS = {
    "臺北市": (900, 450),
    "新北市": (860, 460),
    "桃園市": (820, 480),
}
==================== FILE: main.py ====================

import sys
import os
import uvicorn
from fastapi import FastAPI
from dotenv import load_dotenv

# --- Add project root to Python path ---
# This is to ensure that all modules can be imported correctly, regardless of how the app is run.
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)
# --- End of path modification ---

from server.api.weather import router as weather_router
import asyncio
from server.scheduler import jobs
from server.scheduler.jobs import scheduler

load_dotenv()

app = FastAPI(
    title="Weather Forecast API",
    description="API for providing weather forecasts and sending notifications.",
    version="1.0.0",
)

@app.on_event("startup")
async def startup_event():
    # Trigger the data fetching job to run immediately in the background
    print("Triggering initial data fetch job on startup...")
    asyncio.create_task(jobs.fetch_data_job())
    
    # Start the scheduler for subsequent hourly runs
    scheduler.start()
    print("FastAPI application startup")

@app.on_event("shutdown")
async def shutdown_event():
    scheduler.shutdown()
    print("FastAPI application shutdown")

@app.get("/")
async def root():
    return {"message": "Welcome to the Weather Forecast API"}

app.include_router(weather_router, prefix="/api/weather")

if __name__ == "__main__":
    # Running with 'python -m uvicorn server.main:app' is recommended
    uvicorn.run("server.main:app", host="0.0.0.0", port=8000, reload=True)
==================== FILE: serviceAccountKey.json ====================

{
  "type": "service_account",
  "project_id": "weather-forecast-c62c3",
  "private_key_id": "e34cd2b74d04c8a9b8fab26a565d35ed73cbb51f",
  "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC0AUuynkdexdGU\nIBhu3ZbWXsM53o3Zz7gjIC3P7YdhOl+/nZxU9jZbbJPRyv72cWX8Onk5gBSvcq8y\n1Jo1FMnEJiKrvRaaYMs0LagdB0BSHaj0Y4JGfKeug4vO7zhMc5tti/utTuEnAUM6\nKU+MSL0tVMfV8ZrXi+qAZPmc5yPTweKQ5pZIvWB61JDug2nEgaOq0hsNNYzfvzOP\n1iG7WYQVx/YfDExO5iRUSi5c0iyGlylEFypI5c3ArMq4b66g8Ky3jY2wbOZkQ7HW\nwvnl2wakf8rpC+df+ZW1f9t3fLh+FnAnH5i3adyCPJvDqiWYr1SC8Ikdc5t/LoPX\nKeKt13d1AgMBAAECggEAD8efTFtuE+5RMY7gusinzPIbY4Am55sQitpqzwlabq5l\n2g/l4QLWgAw+0cuIWgVV30HRrQs/2k46R+v1pW/wQhw6ZNtw1vwOREGOX8EUz+i0\nDicyXUiB5fK34l5RN/kt0nF3kNlTM+P7RzwmMjzm10mmh72kM9TFrBdt/xBk287D\n41IjakVSFkmBrdJI4WJ3wO/zp2TS4de1hP1/FPsurrBgyCrm4Sch+0jQmLz61z7O\nN9TjBHZ8Q5Y0Sfhg3q0r8c/avWMSXGI/gTi0Q9J4ePcjfqJ4gir5XXu3m6Wwqryb\nn81DYcxt2MLCcNjTfRGBOYjc4LkeV4s84m5uzzYZPwKBgQDcV5UcagEbink7yYFq\noxKk2/38DioKsvwHJeMis8PDoglDhjawen2cP3wa3dcy0MCns7tFXL+rxlI1SHS7\nlkUUvNLsQWtsbRM89JZLIDHaHuuq/JR77XSJrgWtcQYhtlU7eY+PzvKFJU+wy7mi\nq6Ios5BB6n/HvT1K49inRRL1nwKBgQDRIp07JGaQ5mxe3brEZN+NmiK4LOW5j9uk\ng6i+FenwZ09pj/0X7pvMYR0/kAzxsciv3LqPPehTkbFxTLB5zvs84uQx0SIt4+ID\n3EanZXoL/xYqQbWzHVh4sjWmrsedAcnKJBZyZEwTQrozU/E9N8M95jsmPHsZO6UN\nPN7SsjZyawKBgBCsM+U9hC3wUXIbskY+ZqfA2bwb2kSK/JUR4dj7X0HLXgYU/shl\nzGFpUFu8E4+NyjYmXHJILVyzGf9cJzEWks2Z6B/mZ1mB+2WuYDz5B6yokE6U5Cto\ncVwFpfpUxhEA+fwRG7LXBvTaOOh40egkMpX/2FeUhey4Pg4PpZIqoN+jAoGABCoV\nSW0zIaWE+OqfYnPDw9US5en29Rf5PrBkdsyG6QOVoDt+xbA5p/szEuXybAmnPmE9\n0cZgzvEywFfPl81YUWEPPDK25IUKJhuHyKOLp5t/vH2seZGXBmg+C0CltumnNAA9\n9i8rGKMWhBkiz55BpATmnp9LsDfw1G+m3DkyPlsCgYEAoZsyrQ5NFJyK5i9sXT36\nCecUU3z8RaqIHLsWIq1qrYGk3BO4eB/6ZckZpJ2n5mNEXtZzW2HzWWA4nbn71/Ro\nl+237EvXyx2O309eUNAOFw/leGQTQW3nH4yOrmYd3ScSXQTJFOD4BmajnKxf1ZtE\ny1Ewx0BHkUh4gmYyjemqdPI=\n-----END PRIVATE KEY-----\n",
  "client_email": "firebase-adminsdk-fbsvc@weather-forecast-c62c3.iam.gserviceaccount.com",
  "client_id": "108190628543596458377",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk-fbsvc%40weather-forecast-c62c3.iam.gserviceaccount.com",
  "universe_domain": "googleapis.com"
}

==================== FILE: api\weather.py ====================

from fastapi import APIRouter, HTTPException
from server.core import calculation
from server.scheduler import jobs

router = APIRouter()

@router.get("/ping", summary="Health check")
async def ping():
    return {"status": "ok"}


@router.get("/county/{county_name}", summary="Get CWA Forecast for a County")
async def get_county_forecast(county_name: str):
    """
    Provides a CWA forecast for a specific county based on cached data.
    """
    from urllib.parse import unquote
    decoded_county_name = unquote(county_name)

    cwa_county_data = jobs.get_cached_cwa_county_data()
    if not cwa_county_data or 'records' not in cwa_county_data:
        raise HTTPException(status_code=503, detail="CWA county forecast data is not available yet. Please try again in a moment.")

    # Find county
    target = None
    for loc in cwa_county_data['records'].get('location', []):
        if loc.get('locationName') == decoded_county_name:
            target = loc
            break

    if not target:
        raise HTTPException(status_code=404, detail=f"Forecast for county '{decoded_county_name}' not found.")

    # Simplify county elements (similar approach to township)
    elements = {}
    for element in target.get('weatherElement', []):
        name = element.get('elementName')
        value = None
        time_arr = element.get('time') or []
        if time_arr and time_arr[0].get('parameter'):
            # County dataset uses 'parameter' instead of 'elementValue'
            param = time_arr[0]['parameter']
            value = param.get('parameterName')
        elements[name] = value

    return {
        "county": decoded_county_name,
        "cwa_forecast": {
            "temperature": elements.get("T"),
            "chance_of_rain_12h": elements.get("PoP12h"),
            "weather_description": elements.get("Wx"),
        },
    }


@router.get("/metrics/images", summary="Get image-derived weather metrics")
async def get_image_metrics():
    metrics = jobs.get_cached_image_metrics()
    if not metrics:
        raise HTTPException(status_code=503, detail="Image metrics are not available yet. Please try again in a moment.")
    return metrics


@router.get("/summary", summary="Get combined summary for a county")
async def get_summary(county_name: str):
    """
    Combines CWA county-level temperature/weather with image-derived PoP6/PoP12 and AQI.
    """
    from urllib.parse import unquote
    decoded_county_name = unquote(county_name)
    print(f"[summary] county={decoded_county_name}")

    # County weather from CWA
    cwa_county_data = jobs.get_cached_cwa_county_data()
    if not cwa_county_data or 'records' not in cwa_county_data:
        raise HTTPException(status_code=503, detail="CWA county forecast data is not available yet. Please try again in a moment.")

    target = None
    for loc in cwa_county_data['records'].get('location', []):
        if loc.get('locationName') == decoded_county_name:
            target = loc
            break
    if not target:
        raise HTTPException(status_code=404, detail=f"Forecast for county '{decoded_county_name}' not found.")

    elements = {}
    for element in target.get('weatherElement', []):
        name = element.get('elementName')
        value = None
        time_arr = element.get('time') or []
        if time_arr and time_arr[0].get('parameter'):
            param = time_arr[0]['parameter']
            value = param.get('parameterName')
        elements[name] = value

    # Image metrics
    metrics = jobs.get_cached_image_metrics() or {}

    resp = {
        "county": decoded_county_name,
        "temperature": elements.get("T"),
        "weather_description": elements.get("Wx"),
        "pop12_percent": metrics.get("pop12_percent"),
        "pop6_percent": metrics.get("pop6_percent"),
        "qpf12_mm_per_hr": metrics.get("qpf12_mm_per_hr"),
        "qpf6_mm_per_hr": metrics.get("qpf6_mm_per_hr"),
        "aqi_level": metrics.get("aqi_level"),
    }
    print(f"[summary] resp={resp}")
    return resp


@router.get("/debug/townships", summary="Debug: list discovered township names")
async def debug_list_townships(limit: int = 50):
    data = jobs.get_cached_cwa_township_data()
    if not data:
        return {"townships": []}
    names = calculation.list_township_names(data, limit=limit)
    return {"townships": names, "count": len(names)}


@router.get("/{township_name}", summary="Get CWA Forecast for a Township")
async def get_township_forecast(township_name: str):
    """
    Provides a CWA forecast for a specific township based on cached data.
    """
    from urllib.parse import unquote
    decoded_township_name = unquote(township_name)

    cwa_data = jobs.get_cached_cwa_township_data()

    if not cwa_data:
        raise HTTPException(status_code=503, detail="CWA forecast data is not available yet. Please try again in a moment.")

    forecast = calculation.get_forecast_for_township(
        township_name=decoded_township_name, 
        all_cwa_data=cwa_data
    )

    if not forecast:
        raise HTTPException(status_code=404, detail=f"Forecast for township '{decoded_township_name}' not found.")

    return forecast

==================== FILE: api\__init__.py ====================


==================== FILE: core\calculation.py ====================

def _normalize_name(name: str) -> str:
    if not isinstance(name, str):
        return ""
    # Normalize common variants and whitespace
    return name.replace("台", "臺").replace(" ", "").strip()


def _is_location_match(input_name: str, candidate_name: str) -> bool:
    a = _normalize_name(input_name)
    b = _normalize_name(candidate_name)
    if not a or not b:
        return False
    # Exact, prefix, suffix, or containment (to match county vs township names)
    return (
        a == b
        or a.endswith(b)
        or a.startswith(b)
        or b.endswith(a)
        or b.startswith(a)
        or (b in a)
        or (a in b)
    )


def _iter_all_locations(records: object):
    # Yield all location dicts from various possible shapes
    if not isinstance(records, dict):
        return
    # Case 1: records.location is a list
    loc_list = records.get('location') if isinstance(records, dict) else None
    if isinstance(loc_list, list):
        for loc in loc_list:
            if isinstance(loc, dict):
                yield loc
    # Case 2: records.locations is a list of groups, each with group.location list
    groups = records.get('locations') if isinstance(records, dict) else None
    if isinstance(groups, list):
        for group in groups:
            if isinstance(group, dict):
                for loc in group.get('location', []) if isinstance(group.get('location'), list) else []:
                    if isinstance(loc, dict):
                        # Some structures have an extra nested 'location' list under each county
                        inner = loc.get('location')
                        if isinstance(inner, list):
                            for inner_loc in inner:
                                if isinstance(inner_loc, dict):
                                    yield inner_loc
                        else:
                            yield loc
    # Case 3: records.locations is a dict with key 'location' list
    if isinstance(groups, dict):
        inner_locs = groups.get('location')
        if isinstance(inner_locs, list):
            for loc in inner_locs:
                if isinstance(loc, dict):
                    inner = loc.get('location')
                    if isinstance(inner, list):
                        for inner_loc in inner:
                            if isinstance(inner_loc, dict):
                                yield inner_loc
                    else:
                        yield loc
    # Case 4: Capitalized structure: records['Locations']['Location'] list
    cap_groups = records.get('Locations')
    if isinstance(cap_groups, dict):
        cap_inner = cap_groups.get('Location')
        if isinstance(cap_inner, list):
            for loc in cap_inner:
                if isinstance(loc, dict):
                    inner = loc.get('location') or loc.get('Location')
                    if isinstance(inner, list):
                        for inner_loc in inner:
                            if isinstance(inner_loc, dict):
                                yield inner_loc
                    else:
                        yield loc
    if isinstance(cap_groups, list):
        for group in cap_groups:
            if isinstance(group, dict):
                # group keys example: 'DatasetDescription', 'LocationsName', 'Dataid', 'Location'
                cap_inner = group.get('Location')
                if isinstance(cap_inner, list):
                    for loc in cap_inner:
                        if isinstance(loc, dict):
                            inner = loc.get('location') or loc.get('Location')
                            if isinstance(inner, list):
                                for inner_loc in inner:
                                    if isinstance(inner_loc, dict):
                                        yield inner_loc
                            else:
                                yield loc


def get_forecast_for_township(township_name: str, all_cwa_data: dict):
    """
    Extracts and processes CWA forecast data for a specific township.

    Args:
        township_name: The full name of the township (e.g., "臺北市中正區").
        all_cwa_data: The full JSON response from the CWA township forecast API.

    Returns:
        A dictionary containing the processed forecast, or None if not found.
    """
    if not all_cwa_data or 'records' not in all_cwa_data:
        print("Error: CWA data is invalid or empty.")
        return None

    # 1) Locate township record across all known shapes
    cwa_location_data = None
    records = all_cwa_data['records']
    for loc in _iter_all_locations(records):
        name = None
        if isinstance(loc, dict):
            # Some structures: top-level is county, inner has 'location' list for townships
            inner_list = loc.get('location') or loc.get('Location')
            if isinstance(inner_list, list):
                for inner_loc in inner_list:
                    inner_name = None
                    if isinstance(inner_loc, dict):
                        inner_name = inner_loc.get('locationName') or inner_loc.get('LocationName')
                    if _is_location_match(township_name, inner_name):
                        cwa_location_data = inner_loc
                        break
                if cwa_location_data is not None:
                    break
            name = loc.get('locationName') or loc.get('LocationName')
        if cwa_location_data is None and _is_location_match(township_name, name):
            cwa_location_data = loc
            break

    if not cwa_location_data:
        sample_names = []
        for i, loc in enumerate(_iter_all_locations(records)):
            name = None
            if isinstance(loc, dict):
                name = loc.get('locationName') or loc.get('LocationName')
            if name:
                sample_names.append(name)
            if i >= 9:
                break
        print(f"Error: Township '{township_name}' not found in CWA data. Sample available names: {sample_names}")
        return None

    # 2) Extract weather elements
    weather_elements = {}
    for element in cwa_location_data.get('weatherElement', []):
        element_name = element.get('elementName')
        element_value = "N/A"
        time_arr = element.get('time') or []
        if time_arr:
            first = time_arr[0]
            if isinstance(first, dict) and 'elementValue' in first and first['elementValue']:
                ev = first['elementValue'][0]
                element_value = ev.get('value') if isinstance(ev, dict) else element_value
        if element_name:
            weather_elements[element_name] = element_value

    # 3) Build response
    return {
        "township": township_name,
        "cwa_forecast": {
            "temperature": weather_elements.get("T"),
            "chance_of_rain_12h": weather_elements.get("PoP12h"),
            "weather_description": weather_elements.get("Wx"),
        },
    }


def list_township_names(all_cwa_data: dict, limit: int = 200):
    names = []
    if not isinstance(all_cwa_data, dict):
        return names
    records = all_cwa_data.get('records')
    if not records:
        return names
    for loc in _iter_all_locations(records):
        if isinstance(loc, dict):
            name = loc.get('locationName') or loc.get('LocationName')
            if name:
                names.append(name)
                if len(names) >= limit:
                    break
    return names
==================== FILE: core\data_fetcher.py ====================

import requests
from .. import config

CWA_API_URL = "https://opendata.cwa.gov.tw/api/v1/rest/datastore/"

def get_cwa_township_forecast_data():
    """
    Fetches 36-hour weather forecast data for all townships in Taiwan from the CWA API.
    """
    dataset_id = "F-D0047-091"
    url = f"{CWA_API_URL}{dataset_id}"
    params = {"Authorization": config.CWA_API_KEY}
    
    try:
        print("Fetching CWA township forecast data...")
        response = requests.get(url, params=params, verify=getattr(config, "REQUESTS_VERIFY_SSL", True))
        response.raise_for_status()
        print("Successfully fetched CWA data.")
        return response.json()
    except requests.exceptions.SSLError as e:
        print(f"SSL error fetching CWA township data: {e}")
        if getattr(config, "ALLOW_INSECURE_FALLBACK", False):
            try:
                print("Retrying CWA township request with verify=False (insecure fallback)...")
                response = requests.get(url, params=params, verify=False)
                response.raise_for_status()
                print("Successfully fetched CWA data (insecure fallback).")
                return response.json()
            except requests.exceptions.RequestException as e2:
                print(f"Fallback request failed: {e2}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Error fetching CWA township data: {e}")
        return None

def get_cwa_county_forecast_data():
    """
    Fetches 36-hour weather forecast data for all counties in Taiwan from the CWA API.
    """
    dataset_id = "F-C0032-001"
    url = f"{CWA_API_URL}{dataset_id}"
    params = {"Authorization": config.CWA_API_KEY}
    
    try:
        print("Fetching CWA county forecast data...")
        response = requests.get(url, params=params, verify=getattr(config, "REQUESTS_VERIFY_SSL", True))
        response.raise_for_status()
        print("Successfully fetched CWA county data.")
        return response.json()
    except requests.exceptions.SSLError as e:
        print(f"SSL error fetching CWA county data: {e}")
        if getattr(config, "ALLOW_INSECURE_FALLBACK", False):
            try:
                print("Retrying CWA county request with verify=False (insecure fallback)...")
                response = requests.get(url, params=params, verify=False)
                response.raise_for_status()
                print("Successfully fetched CWA county data (insecure fallback).")
                return response.json()
            except requests.exceptions.RequestException as e2:
                print(f"Fallback request failed: {e2}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Error fetching CWA county data: {e}")
        return None
==================== FILE: core\image_analyzer.py ====================

import io
from typing import Optional, Tuple, Dict, List

import requests
from PIL import Image, ImageFilter, ImageOps

try:
    import pytesseract
except ImportError:  # Optional at import time; function will raise if used without install
    pytesseract = None  # type: ignore


def _download_image(image_url: str) -> Image.Image:
    from server import config
    response = requests.get(image_url, timeout=15, verify=getattr(config, "REQUESTS_VERIFY_SSL", True))
    response.raise_for_status()
    return Image.open(io.BytesIO(response.content)).convert("RGB")


def _ensure_tesseract_is_available() -> None:
    if pytesseract is None:
        raise RuntimeError(
            "pytesseract is not installed. Please add 'pytesseract' to requirements and install Tesseract OCR runtime."
        )


def configure_tesseract_cmd(tesseract_cmd_path: Optional[str]) -> None:
    """
    Optionally configure pytesseract binary path at runtime (useful on Windows).
    """
    if pytesseract and tesseract_cmd_path:
        pytesseract.pytesseract.tesseract_cmd = tesseract_cmd_path


def extract_rain_probability_from_image(image_url: str, crop_box: Optional[Tuple[int, int, int, int]] = None) -> Optional[int]:
    """
    Download an image that contains rain probability text and OCR the value as an integer percentage.

    Args:
        image_url: URL of the image to analyze.
        crop_box: Optional crop region (left, upper, right, lower) targeting the text area for OCR.

    Returns:
        An integer percentage (0-100) if parsed successfully, otherwise None.
    """
    _ensure_tesseract_is_available()

    image = _download_image(image_url)
    if crop_box:
        image = image.crop(crop_box)

    # Simple preprocessing for OCR: grayscale, increase contrast, sharpen
    grayscale = ImageOps.grayscale(image)
    enhanced = grayscale.filter(ImageFilter.SHARPEN)

    ocr_text = pytesseract.image_to_string(enhanced)  # type: ignore[attr-defined]
    # Extract first number sequence as percentage
    digits = []
    for ch in ocr_text:
        if ch.isdigit():
            digits.append(ch)
        elif digits:
            break

    if not digits:
        return None

    try:
        value = int("".join(digits))
        if 0 <= value <= 100:
            return value
        return None
    except ValueError:
        return None


def analyze_aqi_from_image(image_url: str, sample_box: Optional[Tuple[int, int, int, int]] = None) -> Optional[str]:
    """
    Infer AQI qualitative level by sampling color from a designated region.

    The function samples the median color of the region and maps it to standard AQI color bins.

    Args:
        image_url: URL of the AQI map image.
        sample_box: Optional region (left, upper, right, lower) focusing on the legend/target city color.

    Returns:
        One of: "Good", "Moderate", "Unhealthy for Sensitive", "Unhealthy", "Very Unhealthy", "Hazardous"; or None if unknown.
    """
    image = _download_image(image_url)
    if sample_box:
        image = image.crop(sample_box)

    # Downscale and sample a grid to get a robust median color
    small = image.resize((32, 32))
    pixels = list(small.getdata())
    r_values = sorted(p[0] for p in pixels)
    g_values = sorted(p[1] for p in pixels)
    b_values = sorted(p[2] for p in pixels)
    median = (
        r_values[len(r_values) // 2],
        g_values[len(g_values) // 2],
        b_values[len(b_values) // 2],
    )

    return _map_color_to_aqi(median)


def _map_color_to_aqi(rgb: Tuple[int, int, int]) -> Optional[str]:
    r, g, b = rgb

    # Rough color mapping consistent with US EPA AQI colors
    # Good:      Green (~(0-100, 150-255, 0-100))
    # Moderate:  Yellow (~(150-255, 150-255, 0-80))
    # USG:       Orange (~(200-255, 120-180, 0-60))
    # Unhealthy: Red (~(180-255, 0-100, 0-100))
    # Very Unhealthy: Purple (~(150-220, 0-80, 150-220))
    # Hazardous: Maroon (~(100-180, 0-60, 0-60))

    if g > 150 and r < 120 and b < 120:
        return "Good"
    if r > 170 and g > 170 and b < 90:
        return "Moderate"
    if r > 200 and 110 < g < 190 and b < 80:
        return "Unhealthy for Sensitive"
    if r > 180 and g < 110 and b < 110:
        return "Unhealthy"
    if r > 140 and b > 140 and g < 100:
        return "Very Unhealthy"
    if r > 100 and g < 70 and b < 70:
        return "Hazardous"
    return None


def _closest_color(value: Tuple[int, int, int], palette: List[Tuple[int, int, int]]) -> Tuple[int, int, int]:
    vr, vg, vb = value
    best = None
    best_dist = 1e9
    for pr, pg, pb in palette:
        d = (vr - pr) ** 2 + (vg - pg) ** 2 + (vb - pb) ** 2
        if d < best_dist:
            best_dist = d
            best = (pr, pg, pb)
    assert best is not None
    return best


def analyze_qpf_from_image(image_url: str, sample_xy: Tuple[int, int]) -> Optional[float]:
    """
    Estimate rainfall intensity (mm/hr) by sampling color at a given pixel and mapping via QPF_COLOR_MAP.
    """
    from server import config
    image = _download_image(image_url)
    x, y = sample_xy
    if x < 0 or y < 0 or x >= image.width or y >= image.height:
        return None
    rgb = image.getpixel((x, y))[:3] if hasattr(image.getpixel((x, y)), '__iter__') else image.getpixel((x, y))
    palette = list(config.QPF_COLOR_MAP.keys())
    nearest = _closest_color(rgb, palette)
    return config.QPF_COLOR_MAP.get(nearest)



==================== FILE: core\image_url_resolver.py ====================

from datetime import datetime, timedelta
from typing import Iterable, List, Optional

import requests


def _is_image_url(url: str, timeout_seconds: int = 10) -> bool:
    from server import config
    try:
        resp = requests.head(
            url,
            timeout=timeout_seconds,
            allow_redirects=True,
            verify=getattr(config, "REQUESTS_VERIFY_SSL", True),
        )
        if resp.status_code == 200 and 'image' in (resp.headers.get('Content-Type') or '').lower():
            return True
        # Some servers do not support HEAD properly; try GET with small timeout
        resp = requests.get(
            url,
            timeout=timeout_seconds,
            stream=True,
            verify=getattr(config, "REQUESTS_VERIFY_SSL", True),
        )
        content_type = (resp.headers.get('Content-Type') or '').lower()
        return resp.status_code == 200 and 'image' in content_type
    except Exception:
        return False


def _try_patterns(patterns: Iterable[str], times: Iterable[datetime]) -> Optional[str]:
    for ts in times:
        for pattern in patterns:
            candidate = ts.strftime(pattern)
            if _is_image_url(candidate):
                return candidate
    return None


def resolve_latest_url(patterns: List[str], now: Optional[datetime] = None, hours_back: int = 36) -> Optional[str]:
    """
    Try multiple timestamped URL patterns and return the first that exists.
    """
    if not patterns:
        return None
    base_time = now or datetime.utcnow()
    times = [base_time - timedelta(hours=h) for h in range(hours_back + 1)]
    return _try_patterns(patterns, times)



==================== FILE: core\__init__.py ====================


==================== FILE: scheduler\jobs.py ====================

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from server.core import data_fetcher, calculation
from server.core import image_analyzer
from server.core import image_url_resolver
from server import config
from server.services import fcm_sender, discord_sender
import asyncio

scheduler = AsyncIOScheduler()

# --- Data Cache ---
CACHED_CWA_TOWNSHIP_DATA = None
CACHED_CWA_COUNTY_DATA = None
CACHED_IMAGE_METRICS = {
    "rain_probability_percent": None,
    "pop12_percent": None,
    "pop6_percent": None,
    "aqi_level": None,
    "qpf12_mm_per_hr": None,
    "qpf6_mm_per_hr": None,
}
# --- End of Cache ---

async def fetch_data_job():
    """
    Scheduled job to fetch and cache CWA data.
    """
    print("Running scheduled job: fetch_data_job")
    global CACHED_CWA_TOWNSHIP_DATA, CACHED_CWA_COUNTY_DATA, CACHED_IMAGE_METRICS

    CACHED_CWA_TOWNSHIP_DATA = await asyncio.to_thread(
        data_fetcher.get_cwa_township_forecast_data
    )
    CACHED_CWA_COUNTY_DATA = await asyncio.to_thread(
        data_fetcher.get_cwa_county_forecast_data
    )

    # Image-derived metrics
    try:
        if config.TESSERACT_CMD:
            image_analyzer.configure_tesseract_cmd(config.TESSERACT_CMD)
        # Resolve static or dynamic URLs for PoP12 / PoP6 (network I/O -> thread)
        pop12_resolved = await asyncio.to_thread(
            image_url_resolver.resolve_latest_url, config.POP12_URL_PATTERNS
        )
        pop6_resolved = await asyncio.to_thread(
            image_url_resolver.resolve_latest_url, config.POP6_URL_PATTERNS
        )
        pop12_url = (
            config.POP12_IMAGE_URL or pop12_resolved or config.RAIN_PROBABILITY_IMAGE_URL
        )
        pop6_url = (
            config.POP6_IMAGE_URL or pop6_resolved or config.RAIN_PROBABILITY_IMAGE_URL
        )

        # Backward-compatible single PoP (if both None later)
        single_pop_url = config.RAIN_PROBABILITY_IMAGE_URL

        pop12 = await asyncio.to_thread(
            image_analyzer.extract_rain_probability_from_image,
            pop12_url,
            (config.POP12_CROP_BOX or config.RAIN_PROBABILITY_CROP_BOX),
        ) if pop12_url else None
        pop6 = await asyncio.to_thread(
            image_analyzer.extract_rain_probability_from_image,
            pop6_url,
            (config.POP6_CROP_BOX or config.RAIN_PROBABILITY_CROP_BOX),
        ) if pop6_url else None

        pop_single = await asyncio.to_thread(
            image_analyzer.extract_rain_probability_from_image,
            single_pop_url,
            config.RAIN_PROBABILITY_CROP_BOX,
        ) if single_pop_url and pop12 is None and pop6 is None else None
        # Resolve AQI URL (static or dynamic)
        aqi_resolved = await asyncio.to_thread(
            image_url_resolver.resolve_latest_url, config.AQI_URL_PATTERNS
        )
        aqi_url = (config.AQI_IMAGE_URL or aqi_resolved)
        aqi = await asyncio.to_thread(
            image_analyzer.analyze_aqi_from_image,
            aqi_url,
            config.AQI_SAMPLE_BOX,
        ) if aqi_url else None

        # QPF (color sampling) if sample coords exist for this county
        # Use summary county name when computing, here fall back to a default like 臺北市
        default_county = "臺北市"
        sample_xy = config.IMAGE_SAMPLE_COORDS.get(default_county)
        qpf12 = await asyncio.to_thread(
            image_analyzer.analyze_qpf_from_image, pop12_url, sample_xy
        ) if (pop12_url and sample_xy) else None
        qpf6 = await asyncio.to_thread(
            image_analyzer.analyze_qpf_from_image, pop6_url, sample_xy
        ) if (pop6_url and sample_xy) else None
        CACHED_IMAGE_METRICS = {
            "rain_probability_percent": pop_single,
            "pop12_percent": pop12 if pop12 is not None else pop_single,
            "pop6_percent": pop6 if pop6 is not None else pop_single,
            "aqi_level": aqi,
            "qpf12_mm_per_hr": qpf12,
            "qpf6_mm_per_hr": qpf6,
        }
    except Exception as e:
        print(f"Error analyzing images: {e}")
    
    if CACHED_CWA_TOWNSHIP_DATA:
        try:
            # diagnostics: count available township locations
            records = CACHED_CWA_TOWNSHIP_DATA.get('records', {}) if isinstance(CACHED_CWA_TOWNSHIP_DATA, dict) else {}
            print(f"records type: {type(records).__name__}")
            if isinstance(records, dict):
                print(f"records keys: {list(records.keys())[:10]}")
                locs_cap = records.get('Locations')
                if isinstance(locs_cap, dict):
                    print(f"records['Locations'] keys: {list(locs_cap.keys())[:10]}")
                if isinstance(locs_cap, list) and locs_cap:
                    first_keys = list(locs_cap[0].keys()) if isinstance(locs_cap[0], dict) else []
                    print(f"records['Locations'][0] keys: {first_keys}")
            def _iter_locations(rec):
                if isinstance(rec, dict):
                    locs = rec.get('location')
                    if isinstance(locs, list):
                        for loc in locs:
                            yield loc
                    groups = rec.get('locations')
                    if isinstance(groups, list):
                        for g in groups:
                            if isinstance(g, dict):
                                inner = g.get('location')
                                if isinstance(inner, list):
                                    for loc in inner:
                                        yield loc
                    if isinstance(groups, dict):
                        inner = groups.get('location')
                        if isinstance(inner, list):
                            for loc in inner:
                                yield loc
                    # Capitalized variants
                    caps = rec.get('Locations')
                    if isinstance(caps, list):
                        for g in caps:
                            if isinstance(g, dict):
                                inner = g.get('Location')
                                if isinstance(inner, list):
                                    for loc in inner:
                                        yield loc
                    if isinstance(caps, dict):
                        inner = caps.get('Location')
                        if isinstance(inner, list):
                            for loc in inner:
                                yield loc
            sample = []
            count = 0
            for loc in _iter_locations(records):
                count += 1
                if len(sample) < 10 and isinstance(loc, dict):
                    name = loc.get('locationName') or loc.get('LocationName')
                    if name:
                        sample.append(name)
            print(f"Township records discovered: {count}")
            print(f"First township names: {sample}")
        except Exception as _e:
            pass
        print("Scheduled job finished. CWA data has been cached.")
        # After fetching data, check if any notifications need to be sent.
        await check_and_send_notifications()
    else:
        print("Scheduled job finished. CWA data fetching failed.")

async def check_and_send_notifications():
    """
    Checks for notification conditions based on the cached CWA data.
    """
    print("Checking for notification conditions...")
    # Example: A user is subscribed to notifications for "臺北市中正區"
    user_township = "臺北市中正區"
    user_device_token = "DEVICE_TOKEN_HERE" # This would come from a database

    forecast = calculation.get_forecast_for_township(user_township, CACHED_CWA_TOWNSHIP_DATA)

    if forecast and forecast["cwa_forecast"]["chance_of_rain_12h"]:
        pop_value_str = forecast["cwa_forecast"]["chance_of_rain_12h"]
        if pop_value_str and pop_value_str.isdigit():
            pop_value = int(pop_value_str)
            if pop_value > 50: # Condition: chance of rain > 50%
                message = f"Weather Alert for {user_township}: Chance of rain is {pop_value}% in the next 12 hours."
                print(message)
                
                # Send to Discord
                discord_sender.send_to_discord(message)

                # Send FCM push notification (placeholder)
                # fcm_sender.send_notification(
                #      title=f"{user_township} Weather Alert",
                #      body=message,
                #      token=user_device_token
                # )

# Schedule the data fetching job to run periodically (e.g., every hour)
scheduler.add_job(fetch_data_job, 'interval', hours=1)

# --- Getter functions for API endpoints to access cached data ---
def get_cached_cwa_township_data():
    return CACHED_CWA_TOWNSHIP_DATA

def get_cached_cwa_county_data():
    return CACHED_CWA_COUNTY_DATA

def get_cached_image_metrics():
    return CACHED_IMAGE_METRICS
==================== FILE: scheduler\__init__.py ====================


==================== FILE: services\discord_sender.py ====================

import requests
from server import config

def send_to_discord(message: str):
    """
    Sends a message to the Discord webhook URL specified in the config.

    Args:
        message: The string message to send.
    """
    if not config.DISCORD_WEBHOOK_URL or "discord.com" not in config.DISCORD_WEBHOOK_URL:
        # print("Discord webhook URL not configured or invalid. Skipping.")
        return

    payload = {"content": message}
    
    try:
        response = requests.post(config.DISCORD_WEBHOOK_URL, json=payload)
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
        print(f"Successfully sent message to Discord.")
    except requests.exceptions.RequestException as e:
        print(f"Error sending message to Discord: {e}")

==================== FILE: services\fcm_sender.py ====================

import firebase_admin
from firebase_admin import credentials, messaging
from .. import config

# Initialize Firebase Admin SDK
try:
    cred = credentials.Certificate(config.FIREBASE_SERVICE_ACCOUNT_KEY_PATH)
    firebase_admin.initialize_app(cred)
    print("Firebase Admin SDK initialized successfully.")
except Exception as e:
    print(f"Error initializing Firebase Admin SDK: {e}")
    print("Please ensure the service account key path in config.py is correct.")

def send_notification(title: str, body: str, token: str):
    """
    Sends a single notification to a specific device.
    """
    if not firebase_admin._apps:
        print("Firebase Admin SDK not initialized. Cannot send notification.")
        return

    message = messaging.Message(
        notification=messaging.Notification(
            title=title,
            body=body,
        ),
        token=token,
    )

    try:
        response = messaging.send(message)
        print('Successfully sent message:', response)
    except Exception as e:
        print('Error sending message:', e)

==================== FILE: services\__init__.py ====================

